---
title: Vue setup Instance 坑
description: vue option api & composition api ,<script setup></script>,setup()差異
---

###### tags: `前端筆記`

# Vue setup Instance 坑

紀錄一下使用 v-directive 時 , 搭配 < script setup > 踩到的坑

情境: 使用 v-directive + Sortablejs 來完成 custom directive , 
可以到處使用 v-draggable 來快速完成拖曳功能。

## 使用方式


==v-directive 的程式碼==

```js
import Sortable from "sortablejs";
import { deepClone } from "@/composable";

const vDraggable = {
  mounted(el, binding, vnode) {
    const directiveArgument = binding.value;
      onEnd: (evt) => {
        const dragClone = deepClone(binding.instance[directiveArgument.sortData]);
        const [dragItem] = dragClone.splice(evt.oldIndex, 1);
        dragClone.splice(evt.newIndex, 0, dragItem);
        directiveArgument.saveData(dragClone);
      },
    });
  },
};

export default vDraggable;
```

說明一下行為 : 使用者拖曳物件結束後 , 將整把資料深拷貝一次 , 取出被拖的那一筆資料 , 再將它塞到新位置然後存起來。

使用 binding.instance 是為了取得當前的元件實例中變化的資料。

---


==Template 使用的樣子==



```vue
<template>
    <section
        class="drag"
        v-draggable="{
          animation: 400,
          saveData: (data) => {
            product = data
          },
          sortData: 'productFocus',
          dragElement: '.drag__content',
        }"
     >
        <div class="drag__content">
            <p> 我是被拖的 1 號</p>
            <p> 我是被拖的 2 號</p>
            <p> 我是被拖的 3 號</p>
        </div>
    </section>
</template>
```

**[Vue Vustom Directive文件](https://vuejs.org/guide/reusability/custom-directives.html#custom-directives)**


然後一拖...爆了。  哭阿!!!!

查了一輪 , 發現 binding.instance 會拿到 undefined , 所以後續行為就掛了 。

跟泰坦討論了一下 , 原來是 <font color="red">**< script setup >**</font> 的機制與 <font color="red">**Option api**</font> 和 <font color="red">**setup()**</font> 機制不太一樣所以才會導致無法取的 component instance 資料


---


## 透過轉換 js 來觀察不同


==Option API==


```vue
<script >
  export default {
    data(){
      return {
        msg:"Hello World!"
    }
 
  }
</script>

<template>
  <h1>{{ msg }}</h1>
</template>
```

```js
//轉換成 js 的情況
const __sfc__ = {
    data(){
      return {
        msg:"Hello World!" //這裡被 return 
       }
      }
    }
}

import { toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("h1", null, _toDisplayString($data.msg), 1 /* TEXT */))
}
__sfc__.render = render // 執行 render function
__sfc__.__file = "App.vue"
export default __sfc__
```
從 js 中觀察到 執行 render function 前 , data 已經將 msg return 暴露出去了 ,
所以這可以讓我們在 instance 中取得對應值。
 
---
==Setup()==

```vue
<script >
import { ref } from 'vue'
  export default {
    setup(){
      const msg = ref('Hello World!')
      return {
        msg
      }
    }
  }

</script>

<template>
  <h1>{{ msg }}</h1>
</template>

```

```js
//轉換成 js 的情況
import { ref } from 'vue'
  const __sfc__ = {
    setup(){
      const msg = ref('Hello World!')
      return {
        msg //這裡被 return
      }
    }
  }

import { toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (_openBlock(), _createElementBlock("h1", null, _toDisplayString($setup.msg), 1 /* TEXT */))
}
__sfc__.render = render // 執行 render function
__sfc__.__file = "App.vue"
export default __sfc__
```

而 setup() 的情況 ,與 option api 很雷同 ,
同樣在執行 render function 前,就已經將 msg 暴露出去了 , 
所以同樣我們也可以從 instance 中取得對應值

---


==< script setup >==

```vue
<script setup>
import { ref } from 'vue'

const msg = ref('Hello World!')
</script>

<template>
  <h1>{{ msg }}</h1>
</template>
```
```js
//轉換成 js 的情況
import { toDisplayString as _toDisplayString, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"

import { ref } from 'vue'


const __sfc__ = {
  setup(__props) {

const msg = ref('Hello World!') //沒有被 return 

return (_ctx, _cache) => {
  return (_openBlock(), _createElementBlock("h1", null, _toDisplayString(msg.value), 1 /* TEXT */))
 }
}// 直接 return render function

}
__sfc__.__file = "App.vue"
export default __sfc__
```

而 script setup 的行為與上面兩個不同 , 在執行 render function 前,
msg 是沒有被暴露出去的 , 所以我們無法從 instance 中取得對應的值才會看到 undefined

---

因為拖曳情境還有新增項目跟搜尋項目的功能 , 所以需取得當前 instance 的變化樣子 ,
又重新測試一下 , 發現 props 其實也會將 data 暴露出去 ,
所以後來先使用 props 的方式來取得當前的變化值來解決這個坑。